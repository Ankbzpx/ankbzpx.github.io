---
sidebar_position: 2
---

import FlowlineGroup from "@site/src/components/FlowlineGroup";
import ToyViewer from "@site/src/components/ToyViewer";
import RegViewer from "@site/src/components/RegViewer";
import SingularityViewer from "@site/src/components/SingularityViewer";
import InverseParamViewer from "@site/src/components/InverseParamViewer";
import ParamViewer from "@site/src/components/ParamViewer";
import OctInterp from '/img/oct_interp.svg'
import NormalInterp from '/img/normal_interp.svg'


# Neural Implicit Octahedral Field (WIP)

<div class="alert alert--primary" role="alert">
  <strong>WARNING</strong> This project is working in progress (WIP) and results presented here are subject to change
</div>

## Motivation

Ever since the badge generation project, I have been fascinated by the quad mesh modeling. The edge loop centered operators, such as loop insertion and loop slide, enable concise and fine grained control, which are hard to extend for other geometry representations (i.e. the implicit one). However, such benefit doesn't come cheap--the mesh not only needs to be quad dominant, its edge loops also are required to align precisely with geometric features, of which the mesh extracted (i.e. using Marching Cube (MC) or its derivatives) from volume data does not possess.

To bridge the gap, I started with the most obvious solution-- extract first then apply quadrilateral remeshing. After scrutinizing the source code of [Instant meshes](https://github.com/wjakob/instant-meshes), one of the most accessible implementations available in public, I was stunned by how elegant it is. Similar to prior work, a smooth 2D cross field is applied to guide quad tessellation. However, instead of relying on manually specified cross frames, its feature alignment depends purely on smoothing--the cross field automatically snaps to sharp features under sufficient smoothness in 3D ambient space. The initial field is in fact even randomized.

The local smoothness immediately strikes me as a prefect candidate for neural implicit representation, as MLP naturally possess smooth prior. However, the cross field is defined on 2-manifold, and measuring its smoothness requires exhaustive pairwise representation vector matching, which is hard to integrate implicitly. Fortunately, its 3D generalization, the octahedral field, paves both obstacles. Being 3D, the octahedral field naturally defines in euclidean space, where its smoothness can be measured in matching-free fashion, thanks to its Spherical Harmonics (SH) parameterized functional representation. Most prominently, smooth octahedral field in SH parameterization space inherits the same sharp feature alignment property as its 2D counterpart, making it the idea representation.

> **TODO**: Add the section of math background

## Overview
Given a set of uniformly sampled oriented pointcloud as input, we jointly learn implicit representation of both SDF and octahedral field using MLPs.

$$
\begin{aligned}
\text{MLP}_{\text{sdf}}: & \ \mathbb{R}^3 \to \mathbb{R} \\
\text{MLP}_{\text{oct}}: & \ \mathbb{R}^3 \to \mathbb{R}^9
\end{aligned}
$$

For SDF MLP, we use [Siren](https://github.com/vsitzmann/siren) and follow [official implementation](https://github.com/vsitzmann/siren/blob/4df34baee3f0f9c8f351630992c1fe1f69114b5f/loss_functions.py#L214). The octahedral field, on the other hand, is supervised to match the orientation of pointcloud samples, while being locally as smooth as possible elsewhere. To enforce smoothness, instead of directly minimizing the gradient norm, we limit its Lipschitz bound with [LipMLP](https://nv-tlabs.github.io/lip-mlp/). It avoids costly evaluation of high order derivatives and improves the training speed by 50%. Please refers to the publication and code for more details.

> **TODO**: Add links after release

## Key results
### Direct cross field evaluation
Our octahedral MLP encodes volume octahedral field implicitly, that when evaluated on surface using point query, gives similar flowlines as ones solved globally on the manifold

<FlowlineGroup />

> \* with $p=2, \epsilon=0$

Thus, it can save the cross field design step of quadrilateral remeshing.

### Octahedral prior for surface regularization
Upon smoothing, normal aligned octahedral frame converges either to $\pi / 2$ or $\pi$ at infinitesimal. Thus, by aligning it with the gradient of SDF, the octahedral symmetry naturally encourages sharper reconstruction.

<div style={{width: '400px', margin: "0 auto"}}>
    <div class="container">
        <div class="row">
        <div class="col">
        <NormalInterp />
        <p style={{ textAlign: 'center' }}>Smoothed normal interpolation</p>
        </div>
        <div class="col">
        <OctInterp />
        <p style={{ textAlign: 'center' }}>Smoothed octahedral interpolation</p>
        </div>
    </div>
    </div>
</div>

Here is a toy example to demonstrate the regularization

<ToyViewer />

The regularization shines the most for geometry of sharp features. In following example, we surpass baseline for a cleaner and sharper reconstruction, with only $1/4$ of input samples

<RegViewer />

> **Note**: For rendering efficiency, I apply quadratic edge collapsing provided by [MeshLab](https://www.meshlab.net) to MC output. It reduce face count to around 20000 (or 60000 for ones with artifacts) while preserving the original look

### Neural inverse volume parameterization
The octahedral field was originated to guide volume parameterization for hexahedral mesh generation. As hinted in [CubeCover](http://www.mi.fu-berlin.de/en/math/groups/ag-geom/publications/db/2011_Nieser-Reitebuch-Polthier_CubeCover.pdf), a hexahedral tessellation of 3D volume is a regular cube tessellation in parameterization space. Since our implicitly encode zero level set aligned octahedral frame, it might be possible to apply MC in parameterization space, such that the cut would be parallel to one of cube's faces, resulting in quad dominant mesh in original space.

Given cubes need to be cut with MC anyway, we are interested in volume parameterization without integer grid constraint, or namely continuous seamless parameterization.

$$
\int_{V} \| \nabla f- X \|_F^2 \ d{V}
$$
where $f: V \in \mathbb{R}^3 \to V_{param}$

But before that, it is curial to exam the singularity graph first. We visualize it as edges of tetrahedral mesh following CubeCover.

<SingularityViewer />

Our implicit octahedral field gives reasonable singularity graph is ambient space, but some of them are intricate and potentially needs sanitization. However, even if we successfully cut the singularities and compute inversion-free parameterization, it is still challenging to sample a voxel of coordinates in parameterization space and wrap them back to $\mathbb{R}^3$ to query SDF.

Thus, we decide to constrain the problem to singularity free case and tackle the parameterization inversely using a neural based approach
$$
\int_{V_{param}} \| (\nabla f^{-1})^T - X \circ f^{-1} \|_F^2 \ d{V_{param}}
$$
where $f^{-1}: V_{param} \to V \in \mathbb{R}^3$

Specifically, we model $f^{-1}$ as a vector potential. The matching vector potential gradient to the inverse of octahedral frame is roughly equivalent to matching the transpose of the gradient with original octahedral frame, assuming the gradient has been regularized to be orthogonal. So the gradient minimization can performed similarly using the SH parameterization.

Here is an example for singularity-free octahedral field

<InverseParamViewer name='cube_twist' />

Here is an example for singularity free parameterization for an octahedral field that has singularities. The input samples are deliberately rotated so its sharp feature does not align with coordinate axis. The parameterization gives a rough tight oriented bound box, such that apply MC in parameterization space gives more clean and sharp edges. The difference is noticeable when the voxel resolution is low.

<InverseParamViewer name='fandisk_rot' target={[0, 0.05, -0.1]} />

The limited extraction quality is expected:
1. We use three separated MLPs to model SDF, octahedral field and inverse parameterization function, that they are likely not fully match at zero level set.
2. For samples far away from surface, the SH coefficients deviates from octahedral variety much that minimizing $l_2$ norm no long guarantees the correct rotation, leading to inaccurate parameterization. It is especially the case because we sample in parameterization space, that cannot assign larger weight to supervised samples as before.
3. For general vector potential modeled by MLP, asking it to have orthogonal gradient is already difficult, not to mention the further constraints to match octahedral frame.

However, we believe it would be an interesting direction for future research.

#### Bonus
My initial plan was to tackle the volume parameterization with singularity on a tetrahedral mesh, that later realized the problem is much more involved than anticipated (i.e. singularity curve is difficult to cut, the parameterization can have overlaps). But it was a fun experience so I record my attempt here anyway.

<ParamViewer />


## Acknowledgement
Our work is largely inspired by the following work (unordered)
- [Instant Field-Aligned Meshes](https://igl.ethz.ch/projects/instant-meshes/) by Jakob et al.
- [Extrinsically Smooth Direction Fields](https://adshhzy.github.io/projectfolder/ESDF/extrinsic.pdf) by Huang et al.
- [Practical 3D frame field generation](https://dl.acm.org/doi/pdf/10.1145/2980179.2982408) by Ray et al.
- [Algebraic Representations for Volumetric Frame Fields](https://boris.unibe.ch/143298/1/3366786.pdf) by Palmer et al.
- [Octahedral Frames for Feature-Aligned Cross Fields](https://people.csail.mit.edu/jsolomon/assets/crossfields.pdf) by Zhang et al.
- [Designing 2D and 3D Non-Orthogonal Frame Fields](https://inria.hal.science/hal-03287233/file/ff_nonortho.pdf) by Desobry et al.
- [Learning Smooth Neural Functions via Lipschitz Regularization](https://nv-tlabs.github.io/lip-mlp/) by Liu et al.

We thank the python community and the following packages / softwares that our work relies heavily upon (unordered)
- [JAX](https://github.com/google/jax)
- [JAXopt](https://github.com/google/jaxopt)
- [Equinox](https://github.com/patrick-kidger/equinox)
- [Polyscope](https://polyscope.run)
- [Libigl](https://github.com/libigl/libigl)
- Code of [Instant Field-Aligned Meshes](https://github.com/wjakob/instant-meshes)
- Code of [Extrinsically Smooth Direction Fields](https://github.com/adshhzy/SMI2016_Extrinsic)
- Code of [Algebraic Representations for Volumetric Frame Fields](https://github.com/dpa1mer/arff)